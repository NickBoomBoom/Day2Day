/*!
 * Tiny Checklist plugin
 *
 * Copyright (c) 2023 Ephox Corporation DBA Tiny Technologies, Inc.
 * Licensed under the Tiny commercial license. See https://www.tiny.cloud/legal/
 *
 * Version: 2.0.5-52
 */

!function() {
  "use strict";
  const t = t=>parseInt(t, 10)
    , e = (t,e)=>{
      const o = t - e;
      return 0 === o ? 0 : o > 0 ? 1 : -1
  }
    , o = (t,e,o)=>({
      major: t,
      minor: e,
      patch: o
  })
    , n = e=>{
      const n = /([0-9]+)\.([0-9]+)\.([0-9]+)(?:(\-.+)?)/.exec(e);
      return n ? o(t(n[1]), t(n[2]), t(n[3])) : o(0, 0, 0)
  }
    , r = t=>e=>typeof e === t
    , s = t=>"string" === (t=>{
      const e = typeof t;
      return null === t ? "null" : "object" === e && Array.isArray(t) ? "array" : "object" === e && (o = n = t,
      (r = String).prototype.isPrototypeOf(o) || (null === (s = n.constructor) || void 0 === s ? void 0 : s.name) === r.name) ? "string" : e;
      var o, n, r, s
  }
  )(t)
    , i = r("boolean")
    , l = t=>!(t=>null == t)(t)
    , c = r("function")
    , a = r("number");
  class u {
      constructor(t, e) {
          this.tag = t,
          this.value = e
      }
      static some(t) {
          return new u(!0,t)
      }
      static none() {
          return u.singletonNone
      }
      fold(t, e) {
          return this.tag ? e(this.value) : t()
      }
      isSome() {
          return this.tag
      }
      isNone() {
          return !this.tag
      }
      map(t) {
          return this.tag ? u.some(t(this.value)) : u.none()
      }
      bind(t) {
          return this.tag ? t(this.value) : u.none()
      }
      exists(t) {
          return this.tag && t(this.value)
      }
      forall(t) {
          return !this.tag || t(this.value)
      }
      filter(t) {
          return !this.tag || t(this.value) ? this : u.none()
      }
      getOr(t) {
          return this.tag ? this.value : t
      }
      or(t) {
          return this.tag ? this : t
      }
      getOrThunk(t) {
          return this.tag ? this.value : t()
      }
      orThunk(t) {
          return this.tag ? this : t()
      }
      getOrDie(t) {
          if (this.tag)
              return this.value;
          throw new Error(null != t ? t : "Called getOrDie on None")
      }
      static from(t) {
          return l(t) ? u.some(t) : u.none()
      }
      getOrNull() {
          return this.tag ? this.value : null
      }
      getOrUndefined() {
          return this.value
      }
      each(t) {
          this.tag && t(this.value)
      }
      toArray() {
          return this.tag ? [this.value] : []
      }
      toString() {
          return this.tag ? `some(${this.value})` : "none()"
      }
  }
  u.singletonNone = new u(!1);
  const d = (!1,
  ()=>false);
  const m = Array.prototype.indexOf
    , h = (t,e)=>{
      return o = t,
      n = e,
      m.call(o, n) > -1;
      var o, n
  }
    , g = (t,e)=>{
      const o = t.length
        , n = new Array(o);
      for (let r = 0; r < o; r++) {
          const o = t[r];
          n[r] = e(o, r)
      }
      return n
  }
    , f = (t,e)=>{
      for (let o = 0, n = t.length; o < n; o++)
          e(t[o], o)
  }
    , p = (t,e)=>{
      const o = [];
      for (let n = 0, r = t.length; n < r; n++) {
          const r = t[n];
          e(r, n) && o.push(r)
      }
      return o
  }
    , v = Object.keys;
  "undefined" != typeof window ? window : Function("return this;")();
  const k = t=>t.dom.nodeName.toLowerCase()
    , y = t=>e=>(t=>t.dom.nodeType)(e) === t
    , w = y(1)
    , b = y(3)
    , N = y(9)
    , L = y(11)
    , x = t=>e=>w(e) && k(e) === t
    , S = (t,e,o)=>{
      if (!(s(o) || i(o) || a(o)))
          throw console.error("Invalid call to Attribute.set. Key ", e, ":: Value ", o, ":: Element ", t),
          new Error("Attribute value was not simple");
      t.setAttribute(e, o + "")
  }
    , T = (t,e,o)=>{
      S(t.dom, e, o)
  }
    , C = (t,e)=>{
      t.dom.removeAttribute(e)
  }
    , E = (t,e)=>{
      const o = ((t,e)=>{
          const o = t.dom.getAttribute(e);
          return null === o ? void 0 : o
      }
      )(t, e);
      return void 0 === o || "" === o ? [] : o.split(" ")
  }
    , A = t=>void 0 !== t.dom.classList
    , M = t=>E(t, "class")
    , O = (t,e)=>((t,e,o)=>{
      const n = E(t, e).concat([o]);
      return T(t, e, n.join(" ")),
      !0
  }
  )(t, "class", e)
    , j = (t,e)=>((t,e,o)=>{
      const n = p(E(t, e), (t=>t !== o));
      return n.length > 0 ? T(t, e, n.join(" ")) : C(t, e),
      !1
  }
  )(t, "class", e)
    , B = (t,e)=>{
      A(t) ? t.dom.classList.add(e) : O(t, e)
  }
    , D = t=>{
      0 === (A(t) ? t.dom.classList : M(t)).length && C(t, "class")
  }
    , I = (t,e)=>{
      A(t) ? t.dom.classList.remove(e) : j(t, e),
      D(t)
  }
    , P = (t,e)=>A(t) && t.dom.classList.contains(e)
    , R = t=>{
      if (null == t)
          throw new Error("Node cannot be null or undefined");
      return {
          dom: t
      }
  }
    , V = (t,e)=>{
      const o = (e || document).createElement(t);
      return R(o)
  }
    , U = R
    , X = (t,e)=>{
      const o = t.dom;
      if (1 !== o.nodeType)
          return !1;
      {
          const t = o;
          if (void 0 !== t.matches)
              return t.matches(e);
          if (void 0 !== t.msMatchesSelector)
              return t.msMatchesSelector(e);
          if (void 0 !== t.webkitMatchesSelector)
              return t.webkitMatchesSelector(e);
          if (void 0 !== t.mozMatchesSelector)
              return t.mozMatchesSelector(e);
          throw new Error("Browser lacks native selectors")
      }
  }
    , q = t=>u.from(t.dom.parentNode).map(U)
    , z = t=>g(t.dom.childNodes, U)
    , F = t=>((t,e)=>{
      const o = t.dom.childNodes;
      return u.from(o[0]).map(U)
  }
  )(t)
    , K = c(Element.prototype.attachShadow) && c(Node.prototype.getRootNode) ? t=>U(t.dom.getRootNode()) : t=>N(t) ? t : U(t.dom.ownerDocument)
    , Y = t=>U(t.dom.host)
    , $ = t=>{
      const e = b(t) ? t.dom.parentNode : t.dom;
      if (null == e || null === e.ownerDocument)
          return !1;
      const o = e.ownerDocument;
      return (t=>{
          const e = K(t);
          return L(o = e) && l(o.dom.host) ? u.some(e) : u.none();
          var o
      }
      )(U(e)).fold((()=>o.body.contains(e)), (n = $,
      r = Y,
      t=>n(r(t))));
      var n, r
  }
    , G = (t,e)=>({
      left: t,
      top: e,
      translate: (o,n)=>G(t + o, e + n)
  })
    , H = G
    , J = (t,e)=>void 0 !== t ? t : void 0 !== e ? e : 0
    , Q = t=>x("li")(t) && q(t).filter((t=>"ul" === k(t) && P(t, "tox-checklist"))).isSome()
    , W = (t,e)=>e < (t=>{
      const e = t.dom.ownerDocument
        , o = e.body
        , n = e.defaultView
        , r = e.documentElement;
      if (o === t.dom)
          return H(o.offsetLeft, o.offsetTop);
      const s = J(null == n ? void 0 : n.pageYOffset, r.scrollTop)
        , i = J(null == n ? void 0 : n.pageXOffset, r.scrollLeft)
        , l = J(r.clientTop, o.clientTop)
        , c = J(r.clientLeft, o.clientLeft);
      return (t=>{
          const e = t.dom
            , o = e.ownerDocument.body;
          return o === e ? H(o.offsetLeft, o.offsetTop) : $(t) ? (t=>{
              const e = t.getBoundingClientRect();
              return H(e.left, e.top)
          }
          )(e) : H(0, 0)
      }
      )(t).translate(i - c, s - l)
  }
  )(t).left
    , Z = t=>((t,e)=>{
      const o = A(t) ? t.dom.classList.toggle(e) : ((t,e)=>h(M(t), e) ? j(t, e) : O(t, e))(t, e);
      return D(t),
      o
  }
  )(t, "tox-checklist--checked")
    , _ = t=>h(["ul", "ol", "dl"], k(t))
    , tt = t=>(u.from(t).filter((t=>P(t, "tox-checklist"))).bind(F).map((t=>{
      x("li")(t) && F(t).exists(x("ul")) && B(t, "tox-checklist--hidden")
  }
  )),
  t);
  var et = (t,e,o,n,r)=>t(o, n) ? u.some(o) : c(r) && r(o) ? u.none() : e(o, n, r);
  const ot = (t,e,o)=>{
      let n = t.dom;
      const r = c(o) ? o : d;
      for (; n.parentNode; ) {
          n = n.parentNode;
          const t = U(n);
          if (e(t))
              return u.some(t);
          if (r(t))
              break
      }
      return u.none()
  }
    , nt = (t,e)=>{
      t.dom.appendChild(e.dom)
  }
    , rt = (t,e)=>{
      const o = ((t,e)=>{
          const o = V(e)
            , n = (r = t.dom.attributes,
          s = (t,e)=>(t[e.name] = e.value,
          t),
          i = {},
          f(r, ((t,e)=>{
              i = s(i, t)
          }
          )),
          i);
          var r, s, i;
          return ((t,e)=>{
              const o = t.dom;
              ((t,e)=>{
                  const o = v(t);
                  for (let n = 0, r = o.length; n < r; n++) {
                      const r = o[n];
                      e(t[r], r)
                  }
              }
              )(e, ((t,e)=>{
                  S(o, e, t)
              }
              ))
          }
          )(o, n),
          o
      }
      )(t, e);
      var n, r;
      return r = o,
      (t=>u.from(t.dom.nextSibling).map(U))(n = t).fold((()=>{
          q(n).each((t=>{
              nt(t, r)
          }
          ))
      }
      ), (t=>{
          ((t,e)=>{
              q(t).each((o=>{
                  o.dom.insertBefore(e.dom, t.dom)
              }
              ))
          }
          )(t, r)
      }
      )),
      ((t,e)=>{
          f(e, (e=>{
              nt(t, e)
          }
          ))
      }
      )(o, z(t)),
      (t=>{
          const e = t.dom;
          null !== e.parentNode && e.parentNode.removeChild(e)
      }
      )(t),
      o
  }
    , st = (t,e,o)=>ot(t, (t=>X(t, e)), o);
  tinymce.PluginManager.add("checklist", (t=>{
      ((t,o)=>!!t && -1 === ((t,o)=>{
          const n = e(t.major, o.major);
          if (0 !== n)
              return n;
          const r = e(t.minor, o.minor);
          if (0 !== r)
              return r;
          const s = e(t.patch, o.patch);
          return 0 !== s ? s : 0
      }
      )((t=>n((t=>[t.majorVersion, t.minorVersion].join(".").split(".").slice(0, 3).join("."))(t)))(t), n(o)))(tinymce, "6.0.0") ? console.error("The Checklist Plugin requires at least version 6.0.0 of TinyMCE") : (t.on("init", (()=>{
          t.hasPlugin("lists", !0) || t.windowManager.alert("Please use the Checklist Plugin together with the Lists plugin.")
      }
      )),
      (t=>{
          t.on("ListMutation", (t=>{
              const e = u.from(t.element).map(U);
              "IndentList" === t.action || "OutdentList" === t.action ? e.map(tt).map((t=>f(((t,e)=>{
                  const o = void 0 === e ? document : e.dom;
                  return 1 !== (n = o).nodeType && 9 !== n.nodeType && 11 !== n.nodeType || 0 === n.childElementCount ? [] : g(o.querySelectorAll(t), U);
                  var n
              }
              )("ul", t), (t=>tt(t))))) : "ToggleUlList" !== t.action && "ToggleOlList" !== t.action && "ToggleDLList" !== t.action || e.filter(_).map((t=>{
                  I(t, "tox-checklist"),
                  f(z(t), (t=>I(t, "tox-checklist--checked")))
              }
              ))
          }
          ))
      }
      )(t),
      (t=>{
          const e = t=>"ol" === k(t) || "ul" === k(t)
            , o = ()=>{
              const o = U(t.selection.getNode());
              var n, r;
              t.selection.isEditable() && (n = o,
              r = e,
              et(((t,e)=>e(t)), ot, n, r, void 0)).fold((()=>{
                  t.undoManager.transact((()=>{
                      t.execCommand("InsertUnorderedList", !1, {
                          "list-attributes": {
                              class: "tox-checklist"
                          }
                      }),
                      f(p(g(t.selection.getSelectedBlocks(), U), e), (t=>B(t, "tox-checklist")))
                  }
                  ))
              }
              ), (e=>{
                  t.undoManager.transact((()=>{
                      if (P(e, "tox-checklist"))
                          t.execCommand("RemoveList");
                      else {
                          const o = t.selection.getBookmark()
                            , n = rt(e, "ul");
                          B(n, "tox-checklist"),
                          t.selection.moveToBookmark(o)
                      }
                  }
                  ))
              }
              ))
          }
          ;
          t.ui.registry.addToggleButton("checklist", {
              icon: "checklist",
              tooltip: "Insert Checklist",
              onAction: o,
              onSetup: o=>{
                  const n = U(t.getBody())
                    , r = t=>{
                      return o = n,
                      t.dom === o.dom || e(t);
                      var o
                  }
                    , s = e=>o.setActive(!t.readonly && ((t,e,o)=>et(((t,e)=>X(t, e)), st, t, ".tox-checklist", o))(U(e), 0, r).isSome())
                    , i = ()=>{
                      const e = t.selection.isEditable();
                      o.setEnabled(!t.readonly && e)
                  }
                    , l = t=>{
                      s(t.element),
                      i()
                  }
                  ;
                  return t.on("NodeChange", l),
                  s(t.selection.getNode()),
                  i(),
                  ()=>t.off("NodeChange", l)
              }
          }),
          t.ui.registry.addMenuItem("checklist", {
              icon: "checklist",
              text: "Checklist",
              onAction: o,
              onSetup: e=>{
                  const o = ()=>{
                      const o = t.selection.isEditable();
                      e.setEnabled(!t.readonly && o)
                  }
                  ;
                  return t.on("NodeChange", o),
                  o(),
                  ()=>t.off("NodeChange", o)
              }
          })
      }
      )(t),
      (t=>{
          t.shortcuts.add("meta+13", "Check checklist item", (()=>{
              const e = t.selection.getSelectedBlocks();
              f(e, (t=>{
                  const e = U(t);
                  Q(e) && Z(e)
              }
              ))
          }
          ))
      }
      )(t),
      (t=>{
          const e = (t=>{
              let e = t;
              return {
                  get: ()=>e,
                  set: t=>{
                      e = t
                  }
              }
          }
          )(u.none());
          t.on("mousedown touchstart", (o=>{
              const n = U(o.target);
              !((t,e)=>e.exists((e=>"touchstart" === e.type && "mousedown" === t.type && t.timeStamp - e.timeStamp < 250)))(o, e.get()) && Q(n) && W(n, (t=>(t=>"touchstart" === t.type)(t) ? t.touches[0].clientX : t.clientX)(o)) && (e.set(u.some(o)),
              t.undoManager.transact((()=>{
                  o.preventDefault(),
                  Z(n)
              }
              )))
          }
          ))
      }
      )(t))
  }
  ))
}();
